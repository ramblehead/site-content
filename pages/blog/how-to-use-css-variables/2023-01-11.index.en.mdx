---
title: How to use CSS variables
authors:
  - Victor Rybynok
draft: 'private'
datePublished: '2023-02-01'
dateUpdated: '2023-02-08'
description: This post documents how this site came into existence
categories:
  - fun
---

# How to use CSS Variables

The idea is to use JavaScript object reflections capabilities to construct and
map CSS variables from object members. The following snippet outlines the key
function to perform such conversion:

```ts
const makeCssVarName = (
  theme: string,
  group: string,
  name: string,
  cssNamespace = cssNamespaceDefault,
): string => `--${cssNamespace}-${theme}-${group}-${name}`;

const objectToCssVarDefStrs = (
  obj: object,
  theme: string,
  group: string,
  cssNamespace = 'rh',
): string[] => {
  const propsNodes = jsonpath.nodes(obj, '$..*');

  const propsLeaves = propsNodes.filter(
    (node) => typeof node.value !== 'object',
  );

  return propsLeaves.map((prop) => {
    const { path, value } = prop;
    const name = path
      .slice(1)
      .map((i) => toKebabCase(String(i)))
      .join('-');

    return
      `${makeCssVarName(theme, group, name, cssNamespace)}: ${value}`;
  });
};
```

`objectToCssVarDefStrs()` takes an arbitrary JSON-compatible object, theme and
group names, and flattens the given object into a key-value map where
keys are CSS variable names. For example, the following object:

```ts
{
  primary: {
    300: '#93c5fd',
    400: '#60a5fa',
  },
  danger: {
    300: '#fca5a5',
    400: '#f87171',
  },
}
```

is going to converted into the following map assuming `cssNamespace = 'rh'`,
`theme = 'default'` and `group = 'colours'`:

```ts
{
  '--rh-default-colors-primary-300': '#93c5fd',
  '--rh-default-colors-primary-400': '#60a5fa',
  '--rh-default-colors-danger-300': '#fca5a5',
  '--rh-default-colors-danger-400': '#f87171',
}
```

Then, `objectToCssVarDefStrs()` function can be used in a higher level
function `dataToCssVarDefStrs()` as the following:


```ts
const dataToCssVarDefStrs = <CssVarsObj extends object>(
  data: Record<CssVarsGroupName, CssVarsObj>,
  theme: string,
  cssNamespace = 'rh',
): string[] => {
  const result: string[] = [];

  Object.entries(data).forEach(([group, obj]) => {
    Array.prototype.push.apply(
      result,
      objectToCssVarDefStrs(obj, theme, group, cssNamespace),
    );
  });

  return result;
};
```

`dataToCssVarDefStrs()` can then be used to generate different CS global themes
where theme parameters are stored in CSS variables as the following:

```ts
const lightStrs = dataToCssVarDefStrs(defaultLightCssVars, themeName);

const lightCss = css`
  ${lightStrs.join(';\n')};
`;

const darkStrs = dataToCssVarDefStrs(defaultDarkCssVars, themeName);

const darkCss = css`
  ${darkStrs.join(';\n')};
`;

// 'light' class is used as default
const styled = { createGlobalStyle };
export const ThemeDefaultGlobalStyle = styled.createGlobalStyle`
  :root {
    ${lightCss}
  }

  .dark {
    ${darkCss}
  }
`;
```

Lets assume that `defaultLightCssVars` and `defaultDarkCssVars` have the
following values:

```ts
const defaultLightCssVars = {
  colors: {
    primary: {
      300: '#2563eb',
      400: '#3b82f6',
    },
    danger: {
      300: '#fca5a5',
      400: '#f87171',
    },
  },
};

const defaultDarkCssVars = {
  colors: {
    primary: {
      300: '#2563eb',
      400: '#3b82f6',
    },
    danger: {
      300: '#dc2626',
      400: '#ef4444',
    },
  },
};
```

Then the following CSS should be generated by template literal function
`styled.createGlobalStyle`:

```css
:root {
  --rh-default-colors-primary-300: #93c5fd;
  --rh-default-colors-primary-400: #60a5fa;
  --rh-default-colors-danger-300: #fca5a5;
  --rh-default-colors-danger-400: #f87171;
}

.dark {
 --rh-default-colors-primary-300: #2563eb;
 --rh-default-colors-primary-400: #3b82f6;
 --rh-default-colors-danger-300: #dc2626;
 --rh-default-colors-danger-400: #ef4444;
}
```

Theme objects can also be used to generate CSS variable references used as SC
themes `objectToCssVarsObject()`:

```ts
const objectToCssVarsObject = <CssVarsObj extends object>(
  obj: CssVarsObj,
  theme: string,
  group: string,
  cssNamespace = 'rh',
): CssVarsObj => {
  const result = clone(obj) as CssVarsObj;

  const propsNodes = jsonpath.nodes(result, '$..*');

  const propsLeaves = propsNodes.filter(
    (node) => typeof node.value !== 'object',
  );

  propsLeaves.forEach((prop) => {
    const { path } = prop;
    const name = path
      .slice(1)
      .map((i) => toKebabCase(i as string))
      .join('-');

    const cssVar = 
      `var(${makeCssVarName(theme, group, name, cssNamespace)})`;
    jsonpath.value(result, path.join('.'), cssVar);
  });

  return result;
};
```

For the above `defaultLightCssVars` and `defaultLightCssVars`,
`objectToCssVarsObject()` function should produce equal reference objects:

```ts
const defaultCssVars = {
  colors: {
    primary: {
      300: 'var(--rh-default-colors-primary-300)',
      400: 'var(--rh-default-colors-primary-400)',
    },
    danger: {
      300: 'var(--rh-default-colors-danger-300)',
      400: 'var(--rh-default-colors-danger-400)',
    }, 
  },
};
```

Then `defaultCssVars` object can be used as CS theme, providing direct access
to CSS variables which values are determined at browser side from the selected
theme. At the server side, SSR should produce the same output for all themes
allowing to use CS with CSS variable while preserving good development and
refactoring experience.
